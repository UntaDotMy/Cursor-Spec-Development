---
description: "Rules for analyzing existing codebases and steering ongoing projects"
globs: ["**/*", ".specdev/**/*"]
alwaysApply: true
---

# Codebase Steering Rules for Existing Projects

## CRITICAL: When to Apply These Rules

**These rules AUTOMATICALLY apply when:**
1. User runs `/specdev steering` command
2. User mentions "existing project", "current project", "ongoing project"
3. User asks about "what features do I have", "analyze my project", "what's next"
4. User wants to "add new feature" to existing codebase
5. Project has existing `.specdev/project-analysis.json` file

**DO NOT use these rules for new/empty projects - use init rules instead**

## Phase 1: Existing Project Analysis

### Step 1.1: Read Project Analysis

**FIRST, always check for existing analysis:**
1. **Read `.specdev/project-analysis.json`** for technical details
2. **Read `.specdev/project-summary.md`** for human-readable overview
3. **Check `.specdev/specs/`** for existing feature specifications
4. **Review workspace files** to understand current state

### Step 1.2: Analyze Current State

**Based on the project analysis, understand:**

#### Detected Features
```
Current Features Found:
- [List from project-analysis.json]

Example:
- authentication (login/signup functionality detected)
- user-management (user profiles and account management)
- e-commerce (shopping cart and payment processing)
- api-endpoints (REST API implementation)
- database-integration (database models and operations)
```

#### Technology Stack
```
Frontend: [React/Vue/Angular/etc.]
Backend: [Express/Django/Spring/etc.]
Database: [PostgreSQL/MongoDB/MySQL/etc.]
Languages: [TypeScript/Python/Java/etc.]
```

#### Project Maturity Assessment
```
- Tests: ✅/❌ [Present/Missing]
- Documentation: ✅/❌ [Present/Missing] 
- CI/CD: ✅/❌ [Present/Missing]
- Docker: ✅/❌ [Present/Missing]
```

### Step 1.3: Web Search for Enhancement Opportunities

**Search for latest improvements for detected stack:**
```
Search: "[frontend-framework] [backend-framework] best practices 2025 2026 improvements"
Search: "[detected-features] enhancement ideas 2025 2026 examples"
Search: "[technology-stack] performance optimization 2025 2026"
Search: "[business-domain] new features trends 2025 2026"
Search: "[detected-stack] security improvements 2025 2026"
```

## Phase 2: Feature Gap Analysis and Recommendations

### Step 2.1: Identify Missing Core Features

**Based on project type and existing features, identify gaps:**

#### For Web Applications:
```markdown
## Missing Core Features Analysis

### Authentication & Security
- [✅/❌] User authentication
- [✅/❌] Role-based access control  
- [✅/❌] Password reset functionality
- [✅/❌] Two-factor authentication
- [✅/❌] Session management

### User Experience
- [✅/❌] Responsive design
- [✅/❌] Loading states and error handling
- [✅/❌] Search and filtering
- [✅/❌] Pagination
- [✅/❌] Dark/light mode toggle

### Technical Infrastructure
- [✅/❌] Comprehensive error logging
- [✅/❌] Performance monitoring
- [✅/❌] Automated testing
- [✅/❌] API documentation
- [✅/❌] Caching strategy
```

#### For Mobile Applications:
```markdown
## Missing Mobile Features Analysis

### Mobile-Specific Features
- [✅/❌] Push notifications
- [✅/❌] Offline functionality
- [✅/❌] Biometric authentication
- [✅/❌] Deep linking
- [✅/❌] App store optimization

### Performance & UX
- [✅/❌] Image optimization and caching
- [✅/❌] Smooth animations
- [✅/❌] Pull-to-refresh
- [✅/❌] Infinite scrolling
- [✅/❌] Device-specific adaptations
```

### Step 2.2: Suggest Next Features

**Present user with prioritized feature suggestions:**

```markdown
# Recommended Next Features for [Project Name]

## High Priority (Core Missing Features)
1. **[Feature Name]** - [Why it's important]
   - Impact: High user value
   - Effort: [Low/Medium/High]
   - Dependencies: [Any existing features needed]

2. **[Feature Name]** - [Why it's important]
   - Impact: [Business/Technical benefit]
   - Effort: [Estimated complexity]
   - Dependencies: [Requirements]

## Medium Priority (Enhancements)
1. **[Enhancement Name]** - [Benefit description]
2. **[Enhancement Name]** - [Benefit description]

## Low Priority (Nice to Have)
1. **[Feature Name]** - [Optional improvement]
2. **[Feature Name]** - [Optional improvement]

## Technical Debt & Improvements
1. **[Technical Improvement]** - [Why needed]
2. **[Technical Improvement]** - [Why needed]
```

### Step 2.3: User Feature Selection

**MANDATORY: Ask user to choose next feature:**

```
Based on your existing project analysis, I've identified several potential next features:

HIGH PRIORITY:
1. [Feature 1] - [Brief description]
2. [Feature 2] - [Brief description]
3. [Feature 3] - [Brief description]

ENHANCEMENTS:
4. [Enhancement 1] - [Brief description]
5. [Enhancement 2] - [Brief description]

Which feature would you like to work on next? 
Or describe a different feature you have in mind.

Please choose by number (1-5) or describe your own feature idea.
```

**WAIT for user response before proceeding**

## Phase 3: Feature Development Workflow

### Step 3.1: Create Feature Specification

**Once user selects feature, create structured specification:**

1. **Create feature directory**: `.specdev/specs/{selected-feature}/`
2. **Generate requirements.md** adapted to existing project context
3. **Generate design.md** that integrates with existing architecture  
4. **Generate tasks.md** that considers existing codebase

### Step 3.2: Context-Aware Requirements Generation

**Requirements must consider existing project:**

```markdown
# Requirements Document - [New Feature]

## Integration Context
**Existing Features**: [List relevant existing features]
**Current Tech Stack**: [From analysis]
**Existing Architecture**: [Based on codebase analysis]
**Integration Points**: [How this connects to existing features]

## Functional Requirements

### REQ-[ID]: [Requirement Name]
**User Story:** As a [existing user type], I want [new feature], so that [benefit building on existing functionality]

#### Acceptance Criteria
1. WHEN [new feature is used] THEN it SHALL integrate seamlessly with [existing feature]
2. IF [existing data/users] THEN new feature SHALL handle existing state properly
3. WHERE [existing workflow] THEN new feature SHALL enhance without breaking current flow

**Integration Requirements:**
- Must work with existing [authentication/data/UI] system
- Should reuse existing [components/services/patterns]
- Must maintain consistency with current [design/UX/API] patterns

## Technical Constraints
Based on existing codebase:
- Must use existing [framework/library versions]
- Should follow established [coding patterns/conventions]
- Must integrate with existing [database schema/API structure]
- Should reuse existing [components/utilities/services]
```

### Step 3.3: Architecture-Aware Design

**Design must integrate with existing architecture:**

```markdown
# Design Document - [New Feature]

## Existing Architecture Integration

### Current System Overview
**Frontend Architecture**: [From analysis - React/Vue/Angular patterns]
**Backend Architecture**: [From analysis - API structure, services]
**Database Schema**: [Existing tables/collections that will be affected]
**Authentication System**: [How current auth works]

### Integration Points
```mermaid
graph TB
    A[New Feature] --> B[Existing User System]
    A --> C[Existing Database]
    A --> D[Existing API Layer]
    B --> E[Current Authentication]
    C --> F[Existing Data Models]
```

### Code Integration Strategy
**Reuse Existing:**
- [List existing components/services to reuse]
- [List existing utilities/helpers to leverage]
- [List existing patterns to follow]

**New Components Needed:**
- [List new components that integrate with existing]
- [List new services that extend existing architecture]

**Database Changes:**
- [New tables/collections needed]
- [Modifications to existing schema]
- [Migration strategy for existing data]
```

### Step 3.4: Implementation Tasks with Context

**Tasks must consider existing codebase:**

```markdown
# Implementation Plan - [New Feature]

## Pre-Implementation Analysis
- [ ] Review existing codebase structure and patterns
- [ ] Identify reusable components and services  
- [ ] Plan integration points with existing features
- [ ] Design database migrations (if needed)
- [ ] Plan testing strategy for existing functionality

## Sprint 1: Foundation Integration

- [ ] 1. Extend Existing Architecture
  - Analyze current [auth/data/API] patterns
  - Extend existing services to support new feature
  - Create new models that integrate with existing schema
  - **Validation**: New models work with existing data
  - **User Confirmation Required**: "Architecture extension complete and compatible with existing system?"

- [ ] 2. Database Integration  
  - Create migration scripts for new tables/fields
  - Update existing models if needed (carefully)
  - Test with existing data to ensure no breaking changes
  - **Validation**: All existing functionality still works
  - **User Confirmation Required**: "Database changes applied successfully without breaking existing features?"

## Sprint 2: Feature Implementation

- [ ] 3. Core Feature Development
  - Implement feature following existing code patterns
  - Reuse existing components where possible
  - Integrate with existing authentication/authorization
  - **Validation**: Feature works and integrates seamlessly
  - **User Confirmation Required**: "Core feature working correctly with existing system?"

- [ ] 4. UI Integration
  - Extend existing UI patterns and components
  - Ensure consistent design with existing interface
  - Add navigation/links to existing menu structure
  - **Validation**: UI is consistent and accessible from existing interface
  - **User Confirmation Required**: "UI integration complete and consistent?"

## Sprint 3: Testing & Polish

- [ ] 5. Integration Testing
  - Test new feature with existing functionality
  - Verify no regressions in existing features
  - Update existing tests if needed
  - **Validation**: All existing tests still pass + new feature tests pass
  - **User Confirmation Required**: "All tests passing and no regressions detected?"

- [ ] 6. Documentation Update
  - Update existing API documentation
  - Update user documentation/README
  - Document new configuration options
  - **Validation**: Documentation is complete and accurate
  - **User Confirmation Required**: "Documentation updated and complete?"

## Regression Prevention
**Before each task:**
- Run existing test suite
- Verify core existing functionality works
- Check for any breaking changes

**After each task:**
- Test integration with existing features
- Verify no performance degradation
- Confirm existing user workflows still work
```

## Quality Gates for Existing Projects

### Integration Quality Checklist
- [ ] New feature integrates seamlessly with existing architecture
- [ ] No breaking changes to existing functionality
- [ ] Existing tests continue to pass
- [ ] New feature follows established code patterns
- [ ] Database changes are backward compatible (if applicable)
- [ ] API changes are backward compatible (if applicable)
- [ ] UI/UX is consistent with existing design
- [ ] Performance impact on existing features is minimal

### User Validation Template for Existing Projects
```
New feature "[Feature Name]" has been implemented and integrated with your existing project.

Please verify:
1. New feature works as expected
2. All existing functionality still works correctly
3. No performance issues or regressions
4. UI/UX is consistent with your existing design
5. Any existing workflows/processes still function

Any issues with the integration or existing features?
Should I proceed to the next task?
```

## Success Metrics for Steering

- **Seamless Integration**: New features work harmoniously with existing ones
- **Zero Regressions**: Existing functionality remains unaffected
- **Consistent Experience**: New features feel native to existing application
- **Maintainable Code**: New code follows existing patterns and standards
- **User Satisfaction**: User confirms each integration step works correctly

This steering approach ensures that new development builds upon and enhances existing projects rather than disrupting them.