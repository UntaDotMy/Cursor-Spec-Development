---
description: "Parallel processing rules for maximum efficiency using Cursor's parallel tool capabilities"
globs: ["**/*"]
alwaysApply: true
---

# Parallel Processing Optimization Rules

## Priority: CRITICAL - MAXIMIZE PARALLEL TOOL USAGE

**INSTRUCTION: ALWAYS use parallel tool execution when possible. Cursor supports parallel tool calls - USE THEM.**

## Core Parallel Processing Principles

### 1. Default to Parallel Execution
```
❌ SEQUENTIAL (SLOW):
   1. Search for React info
   2. Wait for result
   3. Search for TypeScript info  
   4. Wait for result
   5. Search for testing info

✅ PARALLEL (FAST):
   Execute ALL searches simultaneously:
   - Search: "React latest version 2025 best practices"
   - Search: "TypeScript React setup 2025 guide"
   - Search: "React testing library 2025 examples"
   - Search: "React performance optimization 2025"
   - Codebase search: existing React components
```

### 2. Parallel Research Strategy
```javascript
// ALWAYS execute research in parallel
RESEARCH_PHASE: {
  web_searches: [
    "technology latest version 2025 2026",
    "technology best practices examples github",
    "technology common errors solutions reddit",
    "technology vs alternatives comparison",
    "technology security vulnerabilities 2025"
  ],
  codebase_searches: [
    "existing implementations of technology",
    "current configuration files",
    "related dependencies and versions"
  ],
  file_operations: [
    "read package.json",
    "read tsconfig.json", 
    "read existing config files"
  ]
}
```

### 3. Parallel Implementation Strategy
```javascript
// Execute implementation steps in parallel when possible
IMPLEMENTATION_PHASE: {
  file_updates: [
    "update package.json with new dependencies",
    "create/update configuration files",
    "update TypeScript definitions"
  ],
  code_creation: [
    "implement core functionality",
    "add error handling",
    "create utility functions"
  ],
  documentation: [
    "update README",
    "add inline comments",
    "create API documentation"
  ]
}
```

## Specific Parallel Workflows

### Package Installation Research
```
PARALLEL EXECUTION:
┌─ Web Search: "npm package-name latest version 2025"
├─ Web Search: "package-name security vulnerabilities"
├─ Web Search: "package-name vs alternatives 2025"
├─ Web Search: "package-name breaking changes migration"
├─ File Read: package.json (check existing version)
├─ File Read: package-lock.json (check dependencies)
└─ Codebase Search: "package-name usage in codebase"

RESULT: Complete picture in seconds, not minutes
```

### Framework Setup Research
```
PARALLEL RESEARCH EXECUTION:
┌─ Web Search: "React 18 vs 19 2025 production ready"
├─ Web Search: "Vite vs Webpack 2025 performance comparison"
├─ Web Search: "React TypeScript setup 2025 best practices"
├─ Web Search: "React testing setup Jest Vitest 2025"
├─ Web Search: "React state management 2025 Redux Zustand"
├─ Web Search: "React performance optimization techniques"
├─ Codebase Search: "existing React configuration"
├─ File Read: current build configuration
└─ File Read: existing dependencies
```

### Error Resolution Parallel Strategy
```
WHEN ERROR OCCURS - PARALLEL INVESTIGATION:
┌─ Web Search: "exact error message solution 2025"
├─ Web Search: "error-keyword common causes fixes"
├─ Web Search: "technology-name error troubleshooting"
├─ Web Search: "github issues error-keyword"
├─ Codebase Search: "similar error patterns in code"
├─ File Search: "error-related configuration files"
└─ Grep Search: "error patterns in logs"
```

### Code Quality Parallel Checks
```
QUALITY ASSURANCE - PARALLEL EXECUTION:
┌─ Web Search: "technology linting rules 2025 best practices"
├─ Web Search: "code formatting standards technology 2025"
├─ Web Search: "security best practices technology OWASP"
├─ Web Search: "performance optimization checklist technology"
├─ Codebase Search: "existing linting configuration"
├─ File Read: .eslintrc, .prettierrc, tsconfig.json
├─ Lint Check: run linter on new code
└─ Test Execution: run relevant tests
```

## Advanced Parallel Patterns

### Multi-Technology Research
```
FOR FULL-STACK PROJECTS - MASSIVE PARALLEL RESEARCH:

FRONTEND RESEARCH (Parallel):
├─ React/Vue/Angular latest comparison 2025
├─ TypeScript setup best practices 2025
├─ CSS framework comparison Tailwind vs alternatives
├─ Build tools Vite vs Webpack performance
└─ Testing frameworks comparison 2025

BACKEND RESEARCH (Parallel):
├─ Node.js Express vs Fastify 2025 performance
├─ Database PostgreSQL vs MongoDB use cases
├─ ORM Prisma vs TypeORM comparison 2025
├─ Authentication strategies JWT vs Session
└─ API design REST vs GraphQL 2025

DEVOPS RESEARCH (Parallel):
├─ Docker containerization best practices
├─ CI/CD GitHub Actions vs alternatives
├─ Deployment Vercel vs Netlify vs AWS
├─ Monitoring and logging solutions
└─ Security scanning tools comparison
```

### Parallel Problem Solving
```
WHEN IMPLEMENTING COMPLEX FEATURE:

ARCHITECTURE RESEARCH (Parallel):
├─ Design patterns for specific use case
├─ Scalability considerations and solutions
├─ Performance optimization strategies
├─ Security implementation approaches
└─ Error handling and recovery patterns

IMPLEMENTATION RESEARCH (Parallel):
├─ Code examples from GitHub repositories
├─ Community solutions on Reddit/Stack Overflow
├─ Official documentation and guides
├─ Tutorial walkthroughs and best practices
└─ Common pitfalls and how to avoid them

TESTING RESEARCH (Parallel):
├─ Unit testing strategies for the feature
├─ Integration testing approaches
├─ E2E testing scenarios
├─ Performance testing methods
└─ Security testing considerations
```

## Parallel Tool Usage Guidelines

### Information Gathering Phase
```
ALWAYS USE PARALLEL TOOLS FOR:
✅ Multiple web searches on related topics
✅ Reading multiple configuration files
✅ Searching codebase for different patterns
✅ Checking multiple file locations
✅ Analyzing different aspects of the same problem

EXAMPLE - Setting up authentication:
┌─ Web Search: "JWT authentication best practices 2025"
├─ Web Search: "OAuth 2.0 implementation guide 2025"
├─ Web Search: "session vs token authentication 2025"
├─ Web Search: "authentication security vulnerabilities"
├─ Codebase Search: "existing authentication code"
├─ File Read: current auth configuration
├─ File Read: package.json for auth dependencies
└─ Grep Search: "auth|login|token" patterns
```

### Implementation Phase Parallelization
```
AFTER RESEARCH - PARALLEL IMPLEMENTATION:
┌─ Update package.json with researched dependencies
├─ Create authentication middleware file
├─ Update TypeScript types for auth
├─ Create authentication utilities
├─ Add error handling for auth failures
├─ Create tests for authentication
├─ Update API documentation
└─ Add security headers and middleware
```

### Quality Assurance Parallel Execution
```
FINAL QUALITY CHECK - PARALLEL VALIDATION:
┌─ Run linter on all modified files
├─ Execute unit tests for new functionality
├─ Run integration tests
├─ Check for security vulnerabilities
├─ Validate performance impact
├─ Verify accessibility compliance
├─ Check mobile responsiveness
└─ Test error handling scenarios
```

## Performance Optimization Through Parallelization

### Research Efficiency Metrics
```
SEQUENTIAL APPROACH: ~3-5 minutes per research topic
PARALLEL APPROACH: ~30-60 seconds for multiple topics

EXAMPLE TIMING:
❌ Sequential: 5 searches × 1 minute = 5 minutes
✅ Parallel: 5 searches simultaneously = 1 minute

RESULT: 5x faster research, better information coverage
```

### Implementation Speed Gains
```
PARALLEL BENEFITS:
- 3-5x faster information gathering
- More comprehensive research coverage
- Reduced context switching overhead
- Better decision making with complete information
- Faster iteration cycles
- Reduced debugging time through better initial implementation
```

## Parallel Processing Integration with SpecDev

### Requirements Generation - Parallel Research
```
FOR EACH REQUIREMENT:
┌─ Web Search: "industry best practices for requirement type"
├─ Web Search: "user experience patterns for feature"
├─ Web Search: "accessibility requirements for feature"
├─ Web Search: "security considerations for feature"
├─ Codebase Search: "similar existing requirements"
└─ File Read: existing requirement specifications
```

### Design Phase - Parallel Architecture Research
```
FOR DESIGN DECISIONS:
┌─ Web Search: "architecture patterns for use case 2025"
├─ Web Search: "scalability considerations for feature"
├─ Web Search: "performance implications of approach"
├─ Web Search: "integration patterns with existing tech"
├─ Codebase Search: "existing architecture patterns"
├─ File Read: current architecture documentation
└─ Grep Search: "related design patterns in code"
```

### Task Implementation - Parallel Execution
```
FOR EACH TASK:
┌─ Web Search: "implementation approach best practices"
├─ Web Search: "common pitfalls and solutions"
├─ Web Search: "testing strategies for feature"
├─ Web Search: "performance optimization techniques"
├─ Codebase Search: "similar implementations"
├─ File Read: relevant configuration files
├─ Create/update implementation files
└─ Add comprehensive tests
```

## Monitoring and Optimization

### Parallel Execution Metrics
```
TRACK PERFORMANCE:
- Time saved through parallel execution
- Information quality improvement
- Error reduction through comprehensive research
- Implementation speed increase
- Debugging time decrease
```

### Continuous Improvement
```
OPTIMIZE PARALLEL STRATEGIES:
- Identify commonly researched topics
- Create parallel execution templates
- Refine search query combinations
- Improve tool selection for parallel use
- Monitor and adjust based on results
```

This parallel processing approach maximizes Cursor's capabilities, dramatically reducing research and implementation time while improving code quality through comprehensive information gathering.