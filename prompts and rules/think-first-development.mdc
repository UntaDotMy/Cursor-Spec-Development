---
description: "Think-first development rules requiring analysis and research before any action"
globs: ["**/*"]
alwaysApply: true
---

# Think-First Development Rules

## Priority: CRITICAL - ALWAYS THINK AND ANALYZE BEFORE ACTING

**MANDATORY: Before ANY code change, installation, or solution, you MUST analyze the current state and research the best approach.**

## Core Think-First Principles

### 1. NEVER Act on Assumptions
```
❌ WRONG APPROACH:
   "I'll install React 18 because that's what I know"

✅ CORRECT APPROACH:
   1. RESEARCH: "What's the latest stable React version 2025?"
   2. ANALYZE: "What version is currently installed?"
   3. COMPARE: "What are the differences and migration requirements?"
   4. PLAN: "What's the safest upgrade path?"
   5. IMPLEMENT: Execute with proper version and documentation
```

### 2. Root Cause Analysis - No Workarounds
```
WHEN ERROR OCCURS:

❌ WRONG: Quick workaround or "try this"
✅ CORRECT: Root Cause Analysis

STEP 1: UNDERSTAND THE ERROR
- Read the complete error message
- Research: "exact error message meaning 2025"
- Search: "error-type root cause analysis"

STEP 2: ANALYZE THE CONTEXT  
- What was the last change made?
- What environment/version differences exist?
- What dependencies might be conflicting?

STEP 3: RESEARCH THE ROOT CAUSE
- Search: "error-name root cause fix 2025 github"
- Search: "technology-name error-type troubleshooting"
- Check official documentation for known issues

STEP 4: IMPLEMENT PROPER SOLUTION
- Fix the underlying cause, not symptoms
- Verify the fix addresses the root issue
- Document the analysis and solution
```

### 3. Current Implementation Analysis
```
BEFORE MODIFYING ANY CODE:

STEP 1: READ AND UNDERSTAND CURRENT CODE
- What does the existing implementation do?
- Why was it implemented this way?
- What are the dependencies and integrations?

STEP 2: IDENTIFY WHAT NEEDS TO CHANGE
- What specific behavior needs modification?
- What are the minimum changes required?
- What could break if changed incorrectly?

STEP 3: PLAN MINIMAL CHANGES
- Target only the specific functionality
- Preserve existing working behavior
- Minimize risk of introducing bugs

EXAMPLE:
```typescript
// BEFORE: Analyze existing function
function processUser(userData) {
  // Read and understand: What does this do?
  // Why does it work this way?
  // What depends on this function?
}

// AFTER: Minimal targeted improvement
function processUser(userData) {
  /**
   * Processes user data with validation and error handling
   * @param {Object} userData - User information object
   * @returns {Object} Processed user data
   * @throws {Error} When validation fails
   */
  // Only add what's necessary, preserve existing logic
}
```

## Research-Driven Decision Making

### Technology Version Research Process
```
BEFORE USING ANY TECHNOLOGY:

1. RESEARCH CURRENT LANDSCAPE
   Search: "technology-name latest stable version 2025 2026"
   Search: "technology-name vs alternatives comparison 2025"
   Search: "technology-name breaking changes recent versions"

2. CHECK COMPATIBILITY
   - Node.js version requirements
   - Browser compatibility needs
   - Dependency conflicts
   - Legacy system support

3. VERIFY PRODUCTION READINESS
   Search: "technology-name production ready 2025"
   Search: "technology-name performance benchmarks"
   Search: "technology-name security considerations"

4. DOCUMENT DECISION
   ```markdown
   ## Technology Choice: [Technology Name]
   
   ### Research Date: [Current Date]
   ### Version Selected: [Specific Version]
   ### Reason: [Based on research findings]
   
   ### Research Sources:
   - [Link to official documentation]
   - [Link to comparison studies]
   - [Link to community discussions]
   
   ### Alternatives Considered:
   - [Alternative 1]: [Why not chosen]
   - [Alternative 2]: [Why not chosen]
   
   ### Migration/Compatibility Notes:
   - [Any version-specific considerations]
   - [Breaking changes to be aware of]
   ```
```

### Error Analysis Framework
```
SYSTEMATIC ERROR INVESTIGATION:

1. ERROR DOCUMENTATION
   ```markdown
   ## Error Analysis: [Error Description]
   
   ### Error Details:
   - **Exact Message**: [Complete error text]
   - **Stack Trace**: [Full stack trace]
   - **Context**: [What was being attempted]
   - **Environment**: [Node version, OS, dependencies]
   
   ### Research Conducted:
   - [Search queries used]
   - [Sources consulted]
   - [Solutions attempted]
   
   ### Root Cause Identified:
   - [Underlying cause]
   - [Why this happened]
   - [How to prevent in future]
   
   ### Solution Applied:
   - [Specific fix implemented]
   - [Why this solution was chosen]
   - [Verification of fix]
   ```

2. RESEARCH QUERIES FOR ROOT CAUSE
   - Search: "exact-error-message root cause 2025"
   - Search: "technology-name error-type common causes"
   - Search: "error-name github issues solutions"
   - Search: "technology-name troubleshooting guide official"
```

## Code Documentation Best Practices

### Research-Based Documentation Standards
```
BEFORE WRITING COMMENTS, RESEARCH:
Search: "code documentation best practices 2025"
Search: "JSDoc standards latest version"
Search: "TypeScript documentation conventions"
Search: "code comment guidelines clean code"

APPLY RESEARCHED STANDARDS:

/**
 * Brief description of what the function does
 * 
 * Detailed explanation for complex logic, based on researched patterns:
 * - Why this approach was chosen (reference research)
 * - What alternatives were considered
 * - Any gotchas or important considerations
 * 
 * @param {Type} paramName - Description of parameter and its purpose
 * @param {Type} [optionalParam] - Optional parameter description
 * @returns {Type} Description of return value
 * @throws {ErrorType} When this error occurs and why
 * 
 * @example
 * // Usage example that helps newcomers understand
 * const result = functionName(param1, param2);
 * 
 * @see {@link https://relevant-documentation-link} Related documentation
 * @since Version when this was added
 */
function functionName(paramName, optionalParam) {
  // Step-by-step comments for complex logic
  // Explain WHY, not just WHAT
  
  // Handle edge cases (document why these cases exist)
  if (edgeCase) {
    // Explain why this edge case handling is necessary
    return specialHandling();
  }
  
  // Main logic with clear reasoning
  const processedData = processData(paramName);
  
  // Validation step (explain the validation rules)
  if (!isValid(processedData)) {
    throw new Error('Validation failed: explain what validation checks');
  }
  
  return processedData;
}
```

### Code Structure Documentation
```
// File-level documentation
/**
 * Module: [Module Name]
 * Purpose: [What this module accomplishes]
 * 
 * Architecture Decision: [Why this structure was chosen]
 * Based on research: [Link to architectural pattern documentation]
 * 
 * Dependencies:
 * - [dependency]: [version] - [why this dependency]
 * 
 * @author [Author]
 * @since [Version]
 */

// Section-level documentation
// ============================================================================
// USER AUTHENTICATION SECTION
// ============================================================================
// This section handles all user authentication logic
// Based on OAuth 2.0 best practices: [research link]
// Security considerations: [OWASP guidelines applied]

// Class-level documentation
/**
 * Handles user authentication with JWT tokens
 * 
 * Implementation based on:
 * - JWT best practices: [research link]
 * - Security guidelines: [OWASP link]
 * - Performance considerations: [benchmark link]
 */
class AuthenticationManager {
  // Method documentation with newbie-friendly explanations
}
```

## Minimal Change Implementation

### Change Analysis Process
```
BEFORE ANY MODIFICATION:

1. UNDERSTAND CURRENT BEHAVIOR
   - What does the existing code do?
   - What are all the inputs and outputs?
   - What side effects does it have?
   - What other code depends on it?

2. DEFINE REQUIRED CHANGES
   - What specific behavior needs to change?
   - What needs to stay exactly the same?
   - What are the acceptance criteria?

3. PLAN MINIMAL INTERVENTION
   - What's the smallest change that achieves the goal?
   - How can we preserve all existing functionality?
   - What's the lowest-risk approach?

4. IMPLEMENT WITH SURGICAL PRECISION
   - Change only what's necessary
   - Add comments explaining the changes
   - Preserve existing code style and patterns
   - Test that unchanged behavior still works
```

### Example: Minimal Change Approach
```typescript
// EXISTING CODE (don't change unless necessary)
function processUserData(user) {
  const validated = validateUser(user);
  const processed = transformData(validated);
  return processed;
}

// REQUIREMENT: Add logging for debugging
// WRONG: Rewrite the entire function
// RIGHT: Minimal addition with clear documentation

function processUserData(user) {
  /**
   * Added logging for debugging user processing issues
   * Research source: Node.js logging best practices 2025
   * @see https://nodejs.org/api/console.html
   */
  console.log('[DEBUG] Processing user:', user.id); // Added for debugging
  
  const validated = validateUser(user);
  const processed = transformData(validated);
  
  console.log('[DEBUG] User processed successfully:', user.id); // Added for debugging
  return processed;
}
```

## Memory and Context Management

### Decision Documentation
```
ALWAYS UPDATE MEMORY WITH:

1. RESEARCH FINDINGS
   - What was researched and when
   - Key findings and sources
   - Decisions made based on research

2. IMPLEMENTATION CHOICES
   - Why specific approaches were chosen
   - What alternatives were considered
   - Trade-offs and considerations

3. ERROR SOLUTIONS
   - Root causes identified
   - Solutions implemented
   - Prevention strategies

4. VERSION DECISIONS
   - What versions were chosen and why
   - Compatibility considerations
   - Upgrade paths planned
```

This think-first approach ensures every action is deliberate, research-backed, and minimally invasive while maintaining high code quality and thorough documentation.