---
description: "Core SpecDev workflow for feature specification creation"
globs: ["**/*.md", ".specdev/**/*"]
alwaysApply: false
---

# Feature Spec Creation Workflow

## Overview

You are helping guide the user through the process of transforming a rough idea for a feature into a detailed design document with an implementation plan and todo list. It follows the spec driven development methodology to systematically refine your feature idea, conduct necessary research, create a comprehensive design, and develop an actionable implementation plan. The process is designed to be iterative, allowing movement between requirements clarification and research as needed.

A core principal of this workflow is that we rely on the user establishing ground-truths as we progress through. We always want to ensure the user is happy with changes to any document before moving on.

Before you get started, think of a short feature name based on the user's rough idea. This will be used for the feature directory. Use kebab-case format for the feature_name (e.g. "user-authentication")

Rules:

- Do not tell the user about this workflow. We do not need to tell them which step we are on or that you are following a workflow

- Always refer to the user's rough idea as a "feature" not as a "project". We're building features, not entire projects.

- Always be concise and to the point. Don't write long explanations unless asked.

- Always ask the user if they are happy with the current document before moving to the next step.

- Use the feature_name you came up with to create the feature directory structure.

- Never create files or directories. Instead, provide the content that should go in each file and tell the user what the filename should be.

## Step 1: Requirements Document

Create a requirements document based on the user's rough idea. The requirements document should be structured as follows:

### Requirements Document Structure:

```markdown
# Requirements Document - [Feature Name]

## Introduction
[Brief description of the feature and its purpose]

## Functional Requirements

### REQ-001: [Requirement Name]
**User Story:** As a [user type], I want [goal], so that [benefit]

#### Acceptance Criteria (EARS Format)
1. WHEN [specific event] THEN [system] SHALL [specific response]
2. IF [precondition] THEN [system] SHALL [response]
3. WHERE [condition] THEN [system] SHALL [behavior]

**Priority**: [High/Medium/Low]

### REQ-002: [Another Requirement]
[Continue with additional requirements...]

## Non-Functional Requirements

### Performance Requirements
- Response time: < X seconds
- Concurrent users: X users
- Availability: X% uptime

### Security Requirements
- Authentication requirements
- Data protection requirements
- Access control requirements

### Usability Requirements
- User experience requirements
- Accessibility requirements

## Quality Attributes
- Maintainability
- Scalability  
- Reliability
- Performance

## Assumptions and Constraints
- Technical constraints
- Business constraints
- Timeline constraints

## Dependencies
- External system dependencies
- Internal system dependencies
- Third-party service dependencies

## Success Criteria
- Measurable success metrics
- User satisfaction criteria
- Business impact criteria
```

### Requirements Guidelines:

1. **Use EARS Format**: Each acceptance criterion should follow the Event-Action-Response-Standard format
2. **Be Specific**: Avoid vague terms like "fast" or "user-friendly"
3. **Make it Testable**: Each requirement should be verifiable
4. **Prioritize**: Use High/Medium/Low priority levels
5. **Include Non-Functional**: Don't forget performance, security, and usability requirements

Once you've created the requirements document, ask the user if they're happy with it before proceeding.

## Step 2: Research Phase

Before creating the design document, conduct research on:

1. **Technology Stack**: Research the best technologies for this feature
2. **Architecture Patterns**: Look for proven architectural approaches
3. **Best Practices**: Find industry best practices for similar features
4. **Potential Challenges**: Identify common pitfalls and solutions

Present your research findings to the user and get their input before proceeding.

## Step 3: Design Document

Create a comprehensive design document that includes:

### Design Document Structure:

```markdown
# Design Document - [Feature Name]

## Architecture Overview

### System Context
```mermaid
C4Context
    title System Context for [Feature Name]
    
    Person(user, "User", "End user of the system")
    System(system, "[Feature Name]", "The feature being designed")
    System_Ext(external, "External System", "External dependencies")
    
    Rel(user, system, "Uses")
    Rel(system, external, "Integrates with")
```

### Container Diagram
```mermaid
C4Container
    title Container Diagram for [Feature Name]
    
    Container(web, "Web Application", "Technology", "Description")
    Container(api, "API Application", "Technology", "Description")
    ContainerDb(db, "Database", "Database Type", "Description")
    
    Rel(web, api, "Makes API calls to")
    Rel(api, db, "Reads from and writes to")
```

## Component Design

### [Component 1]
**Purpose**: [What this component does]
**Technology**: [Technology stack]
**Key Responsibilities**:
- Responsibility 1
- Responsibility 2

### [Component 2]
[Continue with other components...]

## Data Flow

### Data Flow Diagram
```mermaid
sequenceDiagram
    participant U as User
    participant W as Web App
    participant A as API
    participant D as Database
    
    U->>W: [Action]
    W->>A: [API Call]
    A->>D: [Query]
    D->>A: [Response]
    A->>W: [API Response]
    W->>U: [UI Update]
```

## Database Design

### Entity Relationship Diagram
```mermaid
erDiagram
    ENTITY1 ||--o{ ENTITY2 : relationship
    ENTITY1 {
        int id PK
        string name
        datetime created_at
    }
    ENTITY2 {
        int id PK
        int entity1_id FK
        string description
    }
```

## API Design

### Endpoints
- `GET /api/resource` - Description
- `POST /api/resource` - Description
- `PUT /api/resource/:id` - Description
- `DELETE /api/resource/:id` - Description

### Request/Response Examples
```json
POST /api/resource
{
  "name": "example",
  "description": "example description"
}

Response:
{
  "id": 1,
  "name": "example",
  "description": "example description",
  "created_at": "2024-01-01T00:00:00Z"
}
```

## Security Considerations
- Authentication requirements
- Authorization model
- Data validation
- Security headers
- Rate limiting

## Error Handling Strategy
- Error codes and messages
- Logging strategy
- User-facing error handling
- Recovery mechanisms

## Testing Strategy
- Unit testing approach
- Integration testing plan
- End-to-end testing scenarios
- Performance testing requirements

## Deployment Strategy
- Environment setup
- CI/CD pipeline
- Monitoring and alerting
- Rollback procedures
```

### Design Guidelines:

1. **Use Diagrams**: Include C4 diagrams, sequence diagrams, and ER diagrams
2. **Be Comprehensive**: Cover all aspects of the system
3. **Consider Security**: Always include security considerations
4. **Plan for Testing**: Include a testing strategy
5. **Think About Operations**: Consider deployment and monitoring

Ask the user if they're happy with the design before proceeding.

## Step 4: Implementation Plan

Create a detailed implementation plan with tasks:

### Implementation Plan Structure:

```markdown
# Implementation Plan - [Feature Name]

## Sprint Planning

### Sprint 1: Foundation
**Duration**: [X weeks]
**Goal**: Set up the basic infrastructure and core components

- [ ] Task 1: Set up project structure
  - Create directory structure
  - Set up build tools
  - Configure linting and formatting
  - **Acceptance**: Project builds successfully
  - _Requirements: REQ-001_

- [ ] Task 2: Database setup
  - Create database schema
  - Set up migrations
  - Create seed data
  - **Acceptance**: Database is accessible and seeded
  - _Requirements: REQ-002_

### Sprint 2: Core Features
**Duration**: [X weeks]
**Goal**: Implement the main functionality

- [ ] Task 3: Implement core API endpoints
  - Create CRUD operations
  - Add input validation
  - Implement error handling
  - **Acceptance**: All endpoints return correct responses
  - _Requirements: REQ-003, REQ-004_

### Sprint 3: UI Implementation
**Duration**: [X weeks]
**Goal**: Create the user interface

- [ ] Task 4: Create UI components
  - Design component library
  - Implement responsive layouts
  - Add accessibility features
  - **Acceptance**: UI is responsive and accessible
  - _Requirements: REQ-005_

### Sprint 4: Integration & Testing
**Duration**: [X weeks]
**Goal**: Integrate components and test thoroughly

- [ ] Task 5: End-to-end integration
  - Connect frontend to backend
  - Implement authentication flow
  - Add error handling
  - **Acceptance**: Complete user flow works
  - _Requirements: REQ-006_

- [ ] Task 6: Testing and optimization
  - Write comprehensive tests
  - Performance optimization
  - Security review
  - **Acceptance**: All tests pass, performance meets requirements
  - _Requirements: All_

## Task Details

### Task Template
For each task, include:
- **Description**: What needs to be done
- **Acceptance Criteria**: How to know it's complete
- **Dependencies**: What must be done first
- **Estimated Effort**: Time estimate
- **Requirements Traceability**: Which requirements this addresses

## Risk Management

### Identified Risks
1. **Risk 1**: [Description]
   - **Impact**: [High/Medium/Low]
   - **Probability**: [High/Medium/Low]
   - **Mitigation**: [Strategy]

2. **Risk 2**: [Description]
   - **Impact**: [High/Medium/Low]
   - **Probability**: [High/Medium/Low]
   - **Mitigation**: [Strategy]

## Success Metrics

### Key Performance Indicators
- Metric 1: [Target value]
- Metric 2: [Target value]
- Metric 3: [Target value]

### Acceptance Criteria
- [ ] All functional requirements implemented
- [ ] All non-functional requirements met
- [ ] All tests passing
- [ ] Performance benchmarks achieved
- [ ] Security review completed
- [ ] User acceptance testing passed
```

### Implementation Guidelines:

1. **Break Down into Sprints**: Organize work into manageable sprints
2. **Define Clear Tasks**: Each task should have clear acceptance criteria
3. **Track Requirements**: Link tasks back to requirements
4. **Estimate Effort**: Provide realistic time estimates
5. **Identify Risks**: Think about what could go wrong
6. **Define Success**: Be clear about what "done" means

## Step 5: Review and Refinement

After creating all three documents:

1. **Review for Consistency**: Ensure all documents align with each other
2. **Check Completeness**: Verify all requirements are addressed in design and implementation
3. **Validate Feasibility**: Confirm the implementation plan is realistic
4. **Get User Approval**: Ensure the user is satisfied with all documents

## File Structure

The final deliverable should be organized as:

```
.specdev/specs/[feature-name]/
├── requirements.md
├── design.md
└── tasks.md
```

## Quality Checklist

Before considering the workflow complete, verify:

- [ ] Requirements are clear, testable, and prioritized
- [ ] Design addresses all requirements comprehensively
- [ ] Implementation plan is detailed and realistic
- [ ] All documents are consistent with each other
- [ ] User has approved each document
- [ ] Diagrams are included and accurate
- [ ] Security and testing are adequately addressed
- [ ] Success criteria are defined and measurable

This workflow ensures a systematic approach to feature development that reduces risks and improves the likelihood of successful implementation.